<html>
	<head>
		<title>Ludum Dare 32: Connection Lost</title>
		<style type="text/css">
			body 
			{
				font-family: sans-serif;
				background: #373333;
				padding: 5%;
				color: white;			
			}
			
			canvas 
			{
				border: solid 2px white;
			}
			
			#resources
			{
				display: none;
			}
			
			
		</style>
		<script type="text/javascript", src="data.js">
		</script>
		<script type="text/javascript">
		
			var canvas;
			var context;
			var game;
			
			var width = 640;
			var height = 512;
			
			var tile_w = 16;
			var tile_h = 16;
			var tile_sf = 4;
			var world_tile_w = tile_w * tile_sf;
			var world_tile_h = tile_h * tile_sf;
			
			//Tile and Sprite Data
			var img_tiles;			//Tiles billing source (image)
			var ts_tiles;			//Tiles TileSet
			var img_sprites;		//Sprites blitting source (image)
			var ts_sprites;			//Sprites TileSet

			var Entity = function(x, y, w, h)
			{
				this.x = x;		//Coordinate on X axis
				this.y = y;		//Coordinate on Y axis
				this.w = w;		//Width
				this.h = h;		//Height
				this.a = true;  //Active
				
				this.getRect = function()
				{
					return {"l": this.x, "t": this.y, "r": (this.x + this.w), "b": (this.y + this.h)};
				}
			
				this.think = function() {};
				this.update = function() {};
				this.draw = function() {};
			}
			
			var TileSet = function(s, m, tw, th)
			{
				console.log("TileSet()");
				this.s = s;		//Image Source
				this.m = m;		//Tile Map
				this.tw = tw;	//Tile Width
				this.th = th;	//Tile Height
			}
			
			var Layer = function(n, d, ts, sf)
			{
				console.log("Layer()");
				this.n = n;				// Layer Name
				this.d = d;				// Layer Array Data
				this.ts = ts;			// Layer Tile Set
				this.sf = sf;			// Layer Scale Factor
				this.v = true;			// Layer visible
				this.pr = true;			// Prerender Layer
				this.c = undefined;		// Layer offscreen surface
				this.ctx = undefined;
				
				this.setVisible = function(v)
				{
					this.v = (v != this.v) ? v : this.v;
				}
				
				this.getContext = function()
				{
					return this.cxt;	
				}
				
				this.preRender = function()
				{
					this.c = document.createElement('canvas');
					this.c.width = (this.d[0].length * (this.ts.tw * this.sf));
					this.c.height = (this.d.length * (this.ts.tw * this.sf));
					
					this.cxt = this.c.getContext('2d');
					this.cxt.imageSmoothingEnabled = false;
					for(var y = 0; y < this.d.length; y++)
					{
						for (var x = 0; x < this.d[0].length; x++)
						{
							//TODO: Apply the scale factor during the draw.
							var tile = this.ts.m[this.d[y][x]];
							this.cxt.drawImage(this.ts.s, tile.c * this.ts.tw, tile.r * this.ts.th, this.ts.tw, this.ts.th, (x * (this.ts.tw * this.sf)), (y * (this.ts.th * this.sf)), (this.ts.tw * this.sf), (this.ts.th * this.sf));
						}
					}
				}
				
				this.draw = function(cr)
				{
					if (this.v)
					{
						context.drawImage(this.c, cr.l, cr.t, (cr.r - cr.l), (cr.b - cr.t), 0 , 0, width, height);
					}
				}
				
				this.preRender();
			}
			
			var World = function(w, h)
			{
				console.log("World()");
				Entity.call(this, 0, 0, w, h);
				
				this.max_entities = 120;
				this.max_projectiles = 50;
								
				this.layers = new Array();
				this.layers.push(new Layer("layer1", layer01, ts_tiles,   tile_sf));
				this.layers.push(new Layer("layer2", layer02, ts_sprites, tile_sf));
				
				this.entities = new Array();
				
				for (var i = 0; i < 15; i++)
				{
					this.entities.push(new Civilian(this.getRect()));
				}
				
				for (var i = 0; i < 5; i++)
				{
					this.entities.push(new Zombie(this.getRect()));
				}
				
				this.player = new Player(this.getRect());
				this.entities.push(this.player);
				
				this.projectiles = new Array();
				
				this.viewport = new ViewPort(0, 0, canvas.width, canvas.height, this.getRect(), this.player);
				
				this.onKeyDown = function(kc)
				{
					this.player.onKeyDown(kc);
				}
				
				this.onKeyUp = function(kc)
				{
					this.player.onKeyUp(kc);
				}
				
				this.addProjectile = function(p)
				{
					if (this.projectiles.length < this.max_projectiles)
					{
						this.projectiles.push(p);
					}
					else
					{
						for (var i = 0; i < this.projectiles.length; i++)
						{
							if (this.projectiles[i].a == false)
							{
								this.projectiles[i] = p;
								break;
							}
						}
					}

				}
				
				this.addEntity = function(e)
				{
					if (this.entities.length < this.max_entities)
					{
						this.entities.push(e);
					}
					else
					{
						for (var i = 0; i < this.entities.length; i++)
						{
							if (this.entities[i].a == false)
							{
								this.entities[i] = e;
								break;
							}
						}
					}
				}
				
				this.collisionRectCheck = function(a,b)
				{
					return !(Math.round(a.t) > Math.round(b.b) || Math.round(a.b) < Math.round(b.t) || Math.round(a.l) > Math.round(b.r) || Math.round(a.r) < Math.round(b.l))
				}
				
				this.update = function()
				{
					var cr = this.viewport.getRect();
					
					for (var i = 0; i < this.entities.length; i++)
					{
						this.entities[i].think();
						this.entities[i].update(cr);
					}
					
					for (var i = 0; i < this.projectiles.length; i++)
					{
						this.projectiles[i].update(cr);
					}
					
					//Check Collisions
					for (var i = 0; i < this.entities.length; i++)
					{
						//Don't check the player against self
						if (this.entities[i].a == false || this.entities[i] == this.player)
							continue;
						
						// Projectiles	
						for (var y = 0; y < this.projectiles.length; y++)
						{
							if (this.projectiles[y].a == true)
							{
								if(this.collisionRectCheck(this.projectiles[y].getRect(), this.entities[i].getRect()))
								{
									this.entities[i].hit(this.projectiles[y]);
									this.projectiles[y].a = false;
								}
							}
						}
						
						if(this.collisionRectCheck(this.player.getRect(), this.entities[i].getRect()))
						{
							this.entities[i].setState(this.entities[i].states.falling);
						}
					}
					
				}
				
				this.draw = function()
				{
					var cr = this.viewport.getRect();
				
					for (var i = 0; i < this.layers.length; i++)
						this.layers[i].draw(cr);

					for (var i = 0; i < this.entities.length; i++)
						this.entities[i].draw(cr);

					for (var i = 0; i < this.projectiles.length; i++)
						this.projectiles[i].draw(cr);
				}
				
			}
			
			var ViewPort = function(x, y, w, h, br, e)
			{
				console.log("ViewPort()");
				Entity.call(this, x, y, w, h);
				
				this.br = br;	//World Bounding Rect;
				this.e = e; 	//Entity to track;
				
				this.getRect = function()
				{
					var l = (this.e.x - (this.e.w / 2)) - (this.w / 2);
					if (l < this.br.l) l = this.br.l;
					else if (l > (this.br.r - this.w)) l = (this.br.r - this.w);
					var t = (this.e.y - (this.e.h / 2)) - (this.h / 2);
					if (t < this.br.t) t = this.br.t;
					else if (t > (this.br.b - this.h)) t = (this.br.b - this.h);
					var r = l + this.w;
					var b = t + this.h;
					return {"l": l, "t": t, "r": r, "b": b};					
				}
			}
			
			
			var Person = function(br, x, y, w, h)
			{
				Entity.call(this, x, y, w, h);
				
				this.br = br;		//World Bounding Rect
				
				this.r = 0;			//Rotation
				this.rs = 16;		//Rotation Steps
				this.rv = 0;		//Rotation Velocity
				this.xv = 0;		//Velocity on X Axis
				this.yv = 0;		//Velocity on Y Axis
				this.t = 0;			//Forward Acceleration (Thrust)
				this.ts = 0;		//Tile Set
				this.af = 0;		//Animation Frame Counter
				this.hp = 100;		//Health
				
				this.shooting = false; //TODO - Sort this out
				
				this.states = {
					'idle': 	{'frames': [0], 			'r': 0,   	't': 0,		'l': true},
					'walkback': {'frames': [0,4,0,1], 		'r': 0.1, 	't': -0.8,	'l': true},
					'walk': 	{'frames': [0,1,0,4], 		'r': 0.1, 	't': 0.8,	'l': true},
					'jog': 		{'frames': [0,1,2,3,4,5,6], 'r': 0.25, 	't': 2,		'l': true},
					'sprint': 	{'frames': [0,1,2,3,4,5,6], 'r': 0.5, 	't': 5,		'l': true},
					'falling': 	{'frames': [8,9,10], 		'r': 0.1, 	't': 0,		'l': false},
					'dying': 	{'frames': [8,9,10], 		'r': 0.1, 	't': 0,		'l': false,	'ns': 'dead'},
					'dead': 	{'frames': [10], 			'r': 0.1, 	't': 0,		'l': false}
				};
				
				this.hit = function(p)
				{
					this.hp -= p.hp;
					game.score += 1;
					if (this.hp < 0)
					{
						this.setState(this.states.dying);
					}
					else
					{
						var ctx = game.getWorld().layers[0].getContext();
						var sprite_name = "splat-0" + (Math.floor(Math.random() * 4) + 1);
						var sprite = map_sprites[sprite_name];
						ctx.save();
						ctx.translate(this.x, this.y);
						ctx.rotate(this.r * (6.282 / this.rs));
						ctx.drawImage(ts_sprites.s, (sprite.c * ts_sprites.tw), (sprite.r * ts_sprites.th), ts_sprites.tw, ts_sprites.th, -(this.w / 2), -(this.h / 2), this.w, this.h);
						ctx.restore();
					}
				}
				
				this.getRect = function()
				{
					var l = this.x - (3 * 4);
					var t = this.y - (4 * 4);
					var r = this.x + (3 * 4);
					var b = this.y + (4 * 4);
					return {"l": l, "t": t, "r": r, "b": b};
				}
				
				this.think = function()
				{
				}
				
				this.setState = function(state)
				{
					if(this.state != state)
					{
						this.state = state;
						this.af = 0;
						if (state.t !== undefined) this.t = state.t;
						
						if(this.state == this.states.dying)
						{
							var ctx = game.getWorld().layers[0].getContext();
							var sprite_name = "stain-0" + (Math.floor(Math.random() * 4) + 1);
							var sprite = map_sprites[sprite_name];
							ctx.save();
							ctx.translate(this.x, this.y);
							ctx.rotate(this.r * (6.282 / this.rs));
							ctx.drawImage(ts_sprites.s, (sprite.c * ts_sprites.tw), (sprite.r * ts_sprites.th), ts_sprites.tw, ts_sprites.th, -(this.w / 2), -(this.h / 2), this.w, this.h);
							ctx.restore();
						}
						else if (this.state == this.states.dead)
						{
							var ctx = game.getWorld().layers[0].getContext();
							var sprite_name = "splat-0" + (Math.floor(Math.random() * 4) + 1);
							var sprite = map_sprites[sprite_name];
							ctx.save();
							ctx.translate(this.x, this.y);
							ctx.rotate(this.r * (6.282 / this.rs));
							ctx.drawImage(ts_sprites.s, (sprite.c * ts_sprites.tw), (sprite.r * ts_sprites.th), ts_sprites.tw, ts_sprites.th, -(this.w / 2), -(this.h / 2), this.w, this.h);
							ctx.drawImage(ts_sprites.s, this.state.frames[Math.floor(this.af)] * ts_sprites.tw, this.ts * ts_sprites.th, ts_sprites.tw, ts_sprites.th, -(this.w / 2), -(this.h / 2), this.w, this.h);
							ctx.restore();
							this.a = false;
							
							var w = game.getWorld();
							game.score += 50;
							w.addEntity(new Civilian(w.getRect()));
							w.addEntity(new Zombie(w.getRect()));
						}
					}
				}
				
				this.rotate = function(amount)
				{
					this.r += amount;
					if (this.r < 0)
					{
						this.r = (this.rs - 1);
					}
					else if (this.r >= this.rs)
					{
						this.r = 0;
					}
				}
				
				this.update = function(cr)
				{
					if(this.a == true)
					{
						this.rotate(this.rv);
						
						//Calculate Movement
						var radians = (this.r * (6.282 / this.rs));
						
						this.xv = this.t * Math.cos(radians);
						this.yv = this.t * Math.sin(radians);
						
						//Calculate new Position
						this.x += this.xv;
						this.y += this.yv;
						
						//TODO: Check movement is onto a valid tile
						
						//Don't exceed bounds
						if (this.x < this.br.l) 
							this.x = this.br.l;
						else if (this.x > this.br.r) 
							this.x = this.br.r;
						if (this.y < this.br.t) 
							this.y = this.br.t;
						else if (this.y > this.br.b) 
							this.y = this.br.b;
						
						//Wind on frame counter, and wrap (TODO: fix the kludge to control speed!)
						this.af += this.state.r;
						if(this.af >= this.state.frames.length)
						{
							if(this.state.l == true)
							{
								this.af = 0;
							}
							else if (this.state.ns !== undefined)
							{
								this.setState(this.states[this.state.ns]);
							}
							else
							{
								this.af = (this.state.frames.length - 1);
							}
						}
						
						if (this.shooting == true)
						{
							var w = game.getWorld();
							w.addProjectile(new Projectile(w.getRect(), this));
						}
					}
				}
				
				this.draw = function(cr)
				{
					if(this.a == true)
					{
						//Only render if on screen
						if ((this.x + this.w) >= cr.l && (this.y + this.h) >= cr.t && this.x <= (cr.r + this.w) && this.y <= (cr.b + this.h))
						{
							context.save();
							context.translate((this.x - cr.l), (this.y - cr.t));
							context.rotate(this.r * (6.282 / this.rs));
							context.drawImage(ts_sprites.s, this.state.frames[Math.floor(this.af)] * tile_w, this.ts * tile_h, tile_w, tile_h, -(this.w / 2), -(this.h / 2), this.w, this.h);
							context.restore();
							
							/*
							var r = this.getRect()						
							context.fillStyle = "red";
							context.fillRect(r.l - cr.l, r.t - cr.t, (r.r - r.l), (r.b - r.t));
							*/
						}
					}
				}
				
				//State Idle
				this.setState(this.states.idle);
			}
			
			var Civilian = function(br)
			{
				var sx = Math.floor((Math.random() * br.r)) + br.l;
				var sy = Math.floor((Math.random() * br.b)) + br.t;
				
				if(Math.floor((Math.random() * 2) + 1) == 1)
					sy = ( Math.floor((Math.random() * 2) + 1) == 1) ? br.t : br.b;
				else
					sx = ( Math.floor((Math.random() * 2) + 1) == 1) ? br.l : br.r;
			
				Person.call(this, br, sx, sy, 64, 64);
				//this.x = Math.floor(Math.random() * ((br.r - br.l) - 40)) + 20;
				//this.y = Math.floor(Math.random() * ((br.b - br.t) - 40)) + 20;
				this.ts = Math.floor(Math.random() * 3) + 1;
				
				this.think = function()
				{
					//Should I turn
					if (Math.floor(Math.random() * 40) == 7)
					{
						this.rv = (Math.floor(Math.random() * 2) -1);
					}
					else
					{
						this.rv = 0;
					}
					
					/*
					//Shall I move
					else if (Math.floor(Math.random() * 9) == 3)
					{
						this.setState(this.states.walk);
					}
					*/
				}
				
				this.setState(this.states.walk);
			}

			var Zombie = function(br)
			{
				Person.call(this, br, width/2, height/2, 64, 64);
				this.x = Math.floor(Math.random() * ((br.r - br.l) - 40)) + 20;
				this.y = Math.floor(Math.random() * ((br.b - br.t) - 40)) + 20;
				this.ts = 4;
				
				this.think = function()
				{
					//Should I turn
					if (Math.floor(Math.random() * 40) == 7)
					{
						this.rotate(Math.floor(Math.random() * 2) -1);
					}
					
					/*
					//Shall I move
					else if (Math.floor(Math.random() * 9) == 3)
					{
						this.setState(this.states.walk);
					}
					*/
				}
				
				this.setState(this.states.walk);
			}
			
			/*
			var Weapon = function(wt, pt)
			{
				this.fr = 0;	//Fire Rate
				this.wt	= 0;	//Weight
				this.am = 0;	//Ammo
				this.ms = 0;	//Magazine size
				
				this.pt = 0;	//Projectile Type
				
				this.shoot = function(e)
				{
					//Generate Projectile
					var w = game.getWorld();
					w.addProjectile(new Projectile(w.getRect(), e));
				}
			}
			*/
			
			var Projectile = function(br, e)
			{
				Entity.call(this, Math.round(e.x), Math.round(e.y), 4, 4);
				
				this.br = br; 		//World Bounding Rectangle
				this.e = e;			//Entity that generated this projectile
				this.r = e.r;		//Rotation
				this.rs = e.rs;		//Rotation Steps
				this.t = 8;			//Projectile Speed
				this.hp = 25;		//Projectile hit points
				
				this.update = function()
				{
					if(this.a == true)
					{
						//Calculate Movement
						var radians = (this.r * (6.282 / this.rs));
						
						this.xv = this.t * Math.cos(radians);
						this.yv = this.t * Math.sin(radians);
					
						this.x += this.xv;
						this.y += this.yv;
					}
				}
				
				this.draw = function(cr)
				{
					if (this.a == true)
					{
						//Only render if on screen
						if ((this.x + this.w) >= cr.l && (this.y + this.h) >= cr.t && this.x <= (cr.r + this.w) && this.y <= (cr.b + this.h))
						{
							context.fillStyle = "yellow";
							context.fillRect(this.x - cr.l, this.y - cr.t, this.w, this.h);
						}
						else
						{
							this.a = false;
						}
					}
				}
				
			}
			
			var Player = function(br)
			{
				Person.call(this, br, br.r/2, br.b/2, 64, 64);
				
				this.rs = 128;
				//this.movement_states = [states.back, states.idle, states.walk, states.jog, states.sprint];
				
				this.onKeyDown = function(kc)
				{
					switch(kc)
					{
						case 32: //Space
							this.shooting = true;
							break;
							
						case 38: // Up
							//TODO: Improve this
							this.setState(this.states.sprint);
							break;
							
						case 37: // Left
							this.rv = -1;
							break;
							
						case 40: // Down
							//TODO: Improve this
							this.setState(this.states.walkback);
							break;
							
						case 39: // Right
							this.rv = 1;
							break;
							
						default:
							console.log("Unhandled Key Event. Code = " + kc);
							break;	
					}
				}
				
				this.onKeyUp = function(kc)
				{
					switch(kc)
					{
						case 32: //Space
							this.shooting = false;
							break;
							
						case 38: // Up
						case 40: //Down
							//TODO: Improve this
							this.setState(this.states.idle);
							break;
							
						case 39: // Right
						case 37: // Left
							this.rv = 0;
							break;
					}
				}
			}
			
			var OSD = function()
			{
				this.score
				
				this.update = function()
				{
				}
				
				this.draw = function()
				{
				}
			}
						
			var Game = function()
			{
				console.log("Game()");
				
				ts_tiles = new TileSet(img_tiles, map_tiles, 16, 16);
				ts_sprites = new TileSet(img_sprites, map_sprites, 16, 16);
				
				this.w = new World((layer01[0].length * world_tile_w), (layer01.length * world_tile_h));
				this.running = true;
				this.score = 0;
				
				this.onKeyDown = function(kc)
				{
					this.w.onKeyDown(kc);
					
					//Main key presses
					switch(kc)
					{
						case 80: //p = pause
							this.running = !this.running;
							tick();
							break;
					}
				}
				
				this.onKeyUp = function(kc)
				{
					this.w.onKeyUp(kc);
				}
				
				this.getWorld = function()
				{
					return this.w;
				}
				
				this.update = function()
				{
					this.w.update();
				}
				
				this.draw = function()
				{
					this.w.draw();
					
					context.save();
					context.font = "24px serif";
					context.fillStyle = "white";
					context.strokeStyle = "black";
					context.textBaseline = "hanging";
					var td = context.measureText(this.score);
					context.fillText(this.score, (width - 10 - td.width), 10);
					context.restore();
				}
			}

			var tick = function()
			{
				context.fillStyle = "black";
				context.fillRect(0, 0, width, height);
				game.update();
				game.draw();
				if(game.running == true)
				{
					window.requestAnimationFrame(tick);
				}
			}

			window.onkeydown = function(e)
			{
				game.onKeyDown(e.keyCode);
				e.preventDefault();
			}
			
			window.onkeyup = function(e)
			{
				game.onKeyUp(e.keyCode);
				e.preventDefault();
			}

			window.onload = function()
			{
				img_sprites = document.getElementById("sprites");
				img_tiles 	= document.getElementById("tiles");
			
				canvas = document.getElementById("canvas");
				context = canvas.getContext("2d");
				context.imageSmoothingEnabled = false;
				
				game = new Game();
				tick();
				
			}

		</script>
	</head>
	<body>
		<div id="resources">
			<image id="sprites" src="resources/sprites.png" width=512 height=512/>
			<image id="tiles" src="resources/tiles.png" width=512 height=512/>
		</div>
		<h1>The Kitchen Sink</h1>
		<canvas id="canvas" width=640px height=512px>
			Canvas is not supported on your browser, try something else!
		</canvas>
		<p>The Kitchen Sink</p>
		<p>Developed in 48 Hours by Connection Lost (Aka Joel Summerfield) for Ludum Dare 32</p>
		<p>It's the distant future, and the world has become a shadow of its former self with corruption and discontent rife throughout all levels of society...<br> But one hope still remains, humanities greatest weapon of last resort is on the brink of deployment. But it just needs a little more time before it can be used. It falls on you, to protect the Kitchen Sink until it is ready to save the world!</p>
	<body>
</html>